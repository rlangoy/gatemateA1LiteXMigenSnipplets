# 03 - CRC32 Peripheral via VHDL Black-Box and Wishbone CSR

Demonstrates how to connect an HDL module (VHDL/Verilog) to the Wishbone bus using LiteX CSR registers on the Olimex GateMate A1 EVB.

## Overview

This project demonstrates how to:

1. Wrap a **VHDL entity** (`hdl/crc.vhdl`) as a Migen black-box using `Instance`
2. Build a **CSR-mapped peripheral** (`CRC32Peripheral`) that exposes the VHDL CRC32 step via two 32-bit CSR registers (data + reset)
3. Use LiteX's **UARTWishboneBridge** to expose the Wishbone bus to the host PC
4. Control and read the peripheral from a **host-side Python script** using `RemoteClient`

The CRC32 step logic is generated by the [Bues Online CRC HDL Generator](https://bues.ch/cms/hacking/crcgen.html). Both VHDL (`hdl/crc.vhdl`) and Verilog (`hdl/crc.v`) variants are provided; the main design uses the VHDL version.

## Architecture

```
 Host PC                         FPGA (GateMate A1)
+-----------------+             +------------------------------------+
|                 |   UART      |                                    |
| litex_server    |<----------->| UARTWishboneBridge                 |
|   (115200 baud) |  TX/RX      |   (Wishbone master)               |
|                 |             |        |                           |
| RemoteClient    |             |        | Wishbone bus              |
|   wb.write()    |             |        v                           |
|   wb.read()     |             |   CSR Decoder (SoCMini)            |
|                 |             |        |                           |
|                 |             |        v                           |
|                 |             |   CRC32Peripheral (CSR slave)           |
|                 |             |     - crc32_data       @ 0x40000800     |
|                 |             |       write [7:0]: data byte in         |
|                 |             |       read [31:0]: CRC32 checksum       |
|                 |             |     - crc32_reset_ctrl @ 0x40000804     |
|                 |             |       write any value: reset to FFFFFFFF|
|                 |             |     - step logic: hdl/crc.vhdl          |
+-----------------+             +------------------------------------+
```

## Files

| File | Description |
|---|---|
| `wishBoneCrsCrc32Vhdl.py` | FPGA design: UART bridge + CSR-mapped CRC32 peripheral backed by VHDL black-box |
| `wishBoneUartDebugCRC32PeripheralModule.py` | Host-side hardware validation script: tests the reset register and CRC accumulation live on the FPGA via `RemoteClient` |
| `testBenchCrc32Peripheral.py` | Simulation testbench with a pure-Migen CRC32 step (VHDL not simulatable by Icarus Verilog) |
| `tbLib/crcLib.py` | Generated Python reference CRC32 implementation used to validate simulation results |
| `hdl/crc.vhdl` | Generated VHDL CRC32 combinatorial step entity (used in synthesis) |
| `hdl/crc.v` | Generated Verilog CRC32 combinatorial step module (alternative, not currently used) |

## Hardware Requirements

- **Board**: Olimex GateMate A1 EVB (CCGM1A1 FPGA)
- **USB-UART adapter** connected to the board's serial pins:
  - TX: `IO_SA_B6`
  - RX: `IO_SA_A6`
- **Clock**: 10 MHz on-board oscillator (`IO_SB_A8`)

## Dependencies

- [Migen](https://github.com/m-labs/migen)
- [LiteX](https://github.com/enjoy-digital/litex) (provides `UARTWishboneBridge`, `RemoteClient`, `litex_server`)
- [LiteX-Boards](https://github.com/litex-hub/litex-boards) (provides the Olimex GateMate A1 EVB platform)
- [Yosys](https://github.com/YosysHQ/yosys) + [openFPGALoader](https://github.com/trabucayre/openFPGALoader) (synthesis and programming)
- **GHDL Yosys plugin** — see one-time setup below

## One-Time Setup: GHDL Yosys Plugin

Standard Yosys has no built-in `read_vhdl` command. To synthesise the VHDL
source (`hdl/crc.vhdl`) the GHDL Yosys plugin (`ghdl.so`) must be built and
installed to your user directory. This is a **one-time step** that requires no
`sudo` / root access.

### Why this is needed

LiteX generates a Yosys script containing `read_vhdl <file>` for every VHDL
source added via `platform.add_source()`. Yosys only recognises this command
when the GHDL plugin is loaded. Ubuntu ships `ghdl` (mcode backend) but not
the plugin, and no pre-built package exists for it.

The build script (`wishBoneCrsCrc32Vhdl.py`) contains a
`GhdlCologneChipToolchain` subclass that automatically:

1. Patches the generated `.ys` script to load the plugin and replace
   `read_vhdl` with the equivalent `ghdl … -e <entity>` command.
2. Sets `LD_LIBRARY_PATH` so the dynamic linker finds the user-local
   `libghdl` and `libgnat` libraries.

You only need to build and install the plugin once. After that,
`python wishBoneCrsCrc32Vhdl.py` works without any further changes.

### Tested versions

| Package | Version |
|---|---|
| Ubuntu | 25.04 (Questing) |
| `ghdl` / `ghdl-mcode` | 5.0.1 |
| `yosys` | 0.52 |
| `ghdl-yosys-plugin` commit | `8c29f2c` (2025-04-06) |

### Build steps

```bash
# 1. Create a working directory
mkdir -p /tmp/ghdl_plugin_build && cd /tmp/ghdl_plugin_build

# 2. Download the required Ubuntu packages (no install / no sudo needed)
apt-get download libghdl-5-0-1 libghdl-dev yosys-dev libgnat-14

# 3. Extract them all into a local prefix
for deb in *.deb; do dpkg-deb -x "$deb" local/; done

# 4. Clone the GHDL Yosys plugin source
git clone https://github.com/ghdl/ghdl-yosys-plugin

# 5. Check out the last commit compatible with GHDL 5.0.1
#    (newer commits use internal GHDL APIs added after 5.0.1)
cd ghdl-yosys-plugin
git fetch --unshallow
git checkout 8c29f2c -- src/ghdl.cc
cd ..

# 6. Compile
g++ -c -fPIC -DYOSYS_ENABLE_GHDL \
    -I local/usr/share/yosys/include \
    -I local/usr/include \
    -D_YOSYS_ -DYOSYS_ENABLE_PLUGINS \
    -DYOSYS_VER=\"0.52\" -DYOSYS_MAJOR=0 -DYOSYS_MINOR=52 \
    -std=c++17 -O2 \
    -DGHDL_VER_HASH="\"8c29f2c\"" \
    ghdl-yosys-plugin/src/ghdl.cc -o ghdl.o

# 7. Link the shared library
mkdir -p ~/.local/lib ~/.local/share/yosys/plugins
g++ -shared -o ~/.local/share/yosys/plugins/ghdl.so ghdl.o \
    local/usr/lib/x86_64-linux-gnu/libghdl-5_0_1.so \
    -Wl,-rpath,"$HOME/.local/lib" \
    -rdynamic -lstdc++ -lm

# 8. Copy the runtime libraries
cp local/usr/lib/x86_64-linux-gnu/libghdl-5_0_1.so ~/.local/lib/
cp local/usr/lib/x86_64-linux-gnu/libgnat-14.so     ~/.local/lib/
```

### Verify

```bash
LD_LIBRARY_PATH=~/.local/lib \
  yosys -p "plugin -i ~/.local/share/yosys/plugins/ghdl.so; \
             ghdl hdl/crc.vhdl -e crc"
```

Expected last line: `Importing module crc.`

## Usage

### 1. Build the bitstream

```bash
python wishBoneCrsCrc32Vhdl.py
```

### 2. Load the bitstream onto the FPGA

```bash
openFPGALoader -c dirtyJtag build/gateware/olimex_gatemate_a1_evb_00.cfg
```

### 3. Start the LiteX UART server

```bash
litex_server --uart --uart-port=/dev/ttyACM0 --debug
```

Adjust `/dev/ttyACM0` to match your USB-UART adapter.

### 4. Control the CRC32 peripheral

```python
from litex import RemoteClient

wb = RemoteClient()
wb.open()

# Reset the CRC32 accumulator to 0xFFFFFFFF
wb.write(0x40000804, 0x1)

# Feed bytes into the CRC32 accumulator (only lower 8 bits are used)
wb.write(0x40000800, 0x31)   # byte '1'
wb.write(0x40000800, 0x32)   # byte '2'
wb.write(0x40000800, 0x33)   # byte '3'

# Read the running CRC32 checksum
value = wb.read(0x40000800)
print(f"CRC32 = 0x{value:08x}")

wb.close()
```

## Register Map

| Address | Bits | R/W | Description |
|---|---|---|---|
| `0x40000000` | — | R/W | SoCMini control register (`ctrl`) |
| `0x40000800` | `[7:0]` | W | Data byte fed into CRC32 accumulator (upper bits `[31:8]` ignored) |
| `0x40000800` | `[31:0]` | R | Running CRC32 checksum (bit-inverted accumulator) |
| `0x40000804` | `[31:0]` | W | Write any value to reset the CRC accumulator to `0xFFFFFFFF` |

Address formula: `csr_base + slot × csr_paging` = `0x40000000 + slot × 0x400`

| Slot | Peripheral | Address |
|---|---|---|
| 0 | `ctrl` | `0x40000000` |
| 2 | `crc32_data` | `0x40000800` |
| 2 | `crc32_reset_ctrl` | `0x40000804` |

## How It Works

- **UARTWishboneBridge** (`litex.soc.cores.uart`) instantiates an RS232 PHY and translates serial commands from `litex_server` into Wishbone bus transactions.
- **CRC32Peripheral** wraps `hdl/crc.vhdl` via a Migen `Instance` (black-box). On each host write to `0x40000800`, the lower 8 bits are passed to the VHDL entity, and the combinatorial output becomes the new accumulator value. Writing any value to `0x40000804` resets the accumulator to `0xFFFFFFFF` (same state as power-on). The accumulator is initialised to `0xFFFFFFFF` on system reset.
- **Read path**: The host reads the bit-inverted accumulator (`~out_buf`), which is the standard CRC32 final-XOR step. At power-on (no bytes written), this reads as `0x00000000`.
- The **CSR decoder** inside `SoCMini` maps the peripheral's CSR register to `0x40000800` using `csr_address_width=14` and `csr_paging=0x400`.

## Hardware Validation

`wishBoneUartDebugCRC32PeripheralModule.py` runs live against the FPGA over UART and checks both the data register and the reset register. Requires `litex_server` to be running first (see step 3 in Usage).

```bash
python wishBoneUartDebugCRC32PeripheralModule.py
```

The script performs five checks in order:

| Step | Action | Address | Expected readback |
|---|---|---|---|
| Reset | Write `0x1` to reset register | `0x40000804` | `0x00000000` |
| Test 1 | Write byte `0x31` ('1') | `0x40000800` | `0x83DCEFB7` |
| Test 2 | Write byte `0x32` ('2') | `0x40000800` | `0x4F5344CD` |
| Test 3 | Write byte `0x33` ('3') | `0x40000800` | `0x884863D2` |
| Test 4 | Reset again via `0x40000804` | `0x40000804` | `0x00000000` |
| Test 5 | Write byte `0x31` again | `0x40000800` | `0x83DCEFB7` (same as Test 1) |

Tests 4 and 5 together verify that the reset register correctly clears the accumulator — re-feeding `0x31` after a reset must produce the same checksum as the very first write.

## Running Tests

```bash
python testBenchCrc32Peripheral.py
```

The testbench uses a pure-Migen CRC32 step (bit-for-bit mirror of `hdl/crc.vhdl`) because Icarus Verilog cannot simulate VHDL black-boxes. All other peripheral logic is identical to the synthesis design.

The simulation verifies:

- **Test 1**: Checksum at power-on (no writes) equals `0x00000000`
- **Test 2**: Single byte `0x31` produces the correct CRC32
- **Test 3**: Accumulation continues correctly after further bytes
- **Test 4**: System reset clears the accumulator back to initial state
- **Test 5**: Byte-by-byte accumulation of `0xDEADBEEF` matches `tbLib/crcLib.py` at every step
- **Test 6**: Upper bits `[31:8]` in a write are ignored — `0xDEADBE31` is treated as `0x31`

A `test_crc32_peripheral.vcd` waveform file is generated for inspection in GTKWave.
