# 03 - CRC32 Peripheral via VHDL Black-Box and Wishbone CSR

Demonstrates how to connect an HDL module (VHDL/Verilog) to the Wishbone bus using LiteX CSR registers on the Olimex GateMate A1 EVB.

## Overview

This project demonstrates how to:

1. Wrap a **VHDL entity** (`hdl/crc.vhdl`) as a Migen black-box using `Instance`
2. Build a **CSR-mapped peripheral** (`CRC32Peripheral`) that exposes the VHDL CRC32 step via a single 32-bit CSR register
3. Use LiteX's **UARTWishboneBridge** to expose the Wishbone bus to the host PC
4. Control and read the peripheral from a **host-side Python script** using `RemoteClient`

The CRC32 step logic is generated by the [Bues Online CRC HDL Generator](https://bues.ch/cms/hacking/crcgen.html). Both VHDL (`hdl/crc.vhdl`) and Verilog (`hdl/crc.v`) variants are provided; the main design uses the VHDL version.

## Architecture

```
 Host PC                         FPGA (GateMate A1)
+-----------------+             +------------------------------------+
|                 |   UART      |                                    |
| litex_server    |<----------->| UARTWishboneBridge                 |
|   (115200 baud) |  TX/RX      |   (Wishbone master)               |
|                 |             |        |                           |
| RemoteClient    |             |        | Wishbone bus              |
|   wb.write()    |             |        v                           |
|   wb.read()     |             |   CSR Decoder (SoCMini)            |
|                 |             |        |                           |
|                 |             |        v                           |
|                 |             |   CRC32Peripheral (CSR slave)      |
|                 |             |     - crc32_data @ 0x40000800      |
|                 |             |     - write [7:0]: data byte in    |
|                 |             |     - read [31:0]: CRC32 checksum  |
|                 |             |     - step logic: hdl/crc.vhdl     |
+-----------------+             +------------------------------------+
```

## Files

| File | Description |
|---|---|
| `wishBoneCrsCrc32Vhdl.py` | FPGA design: UART bridge + CSR-mapped CRC32 peripheral backed by VHDL black-box |
| `testBenchCrc32Peripheral.py` | Simulation testbench with a pure-Migen CRC32 step (VHDL not simulatable by Icarus Verilog) |
| `tbLib/crcLib.py` | Generated Python reference CRC32 implementation used to validate simulation results |
| `hdl/crc.vhdl` | Generated VHDL CRC32 combinatorial step entity (used in synthesis) |
| `hdl/crc.v` | Generated Verilog CRC32 combinatorial step module (alternative, not currently used) |

## Hardware Requirements

- **Board**: Olimex GateMate A1 EVB (CCGM1A1 FPGA)
- **USB-UART adapter** connected to the board's serial pins:
  - TX: `IO_SA_B6`
  - RX: `IO_SA_A6`
- **Clock**: 10 MHz on-board oscillator (`IO_SB_A8`)

## Dependencies

- [Migen](https://github.com/m-labs/migen)
- [LiteX](https://github.com/enjoy-digital/litex) (provides `UARTWishboneBridge`, `RemoteClient`, `litex_server`)
- [LiteX-Boards](https://github.com/litex-hub/litex-boards) (provides the Olimex GateMate A1 EVB platform)
- [Yosys](https://github.com/YosysHQ/yosys) + [openFPGALoader](https://github.com/trabucayre/openFPGALoader) (synthesis and programming)

## Usage

### 1. Build the bitstream

```bash
python wishBoneCrsCrc32Vhdl.py
```

### 2. Load the bitstream onto the FPGA

```bash
openFPGALoader -c dirtyJtag build/gateware/olimex_gatemate_a1_evb_00.cfg
```

### 3. Start the LiteX UART server

```bash
litex_server --uart --uart-port=/dev/ttyACM0 --debug
```

Adjust `/dev/ttyACM0` to match your USB-UART adapter.

### 4. Control the CRC32 peripheral

```python
from litex import RemoteClient

wb = RemoteClient()
wb.open()

# Feed bytes into the CRC32 accumulator (only lower 8 bits are used)
wb.write(0x40000800, 0x31)   # byte '1'
wb.write(0x40000800, 0x32)   # byte '2'
wb.write(0x40000800, 0x33)   # byte '3'

# Read the running CRC32 checksum
value = wb.read(0x40000800)
print(f"CRC32 = 0x{value:08x}")

wb.close()
```

## Register Map

| Address | Bits | R/W | Description |
|---|---|---|---|
| `0x40000000` | — | R/W | SoCMini control register (`ctrl`) |
| `0x40000800` | `[7:0]` | W | Data byte fed into CRC32 accumulator (upper bits `[31:8]` ignored) |
| `0x40000800` | `[31:0]` | R | Running CRC32 checksum (bit-inverted accumulator) |

Address formula: `csr_base + slot × csr_paging` = `0x40000000 + slot × 0x400`

| Slot | Peripheral | Address |
|---|---|---|
| 0 | `ctrl` | `0x40000000` |
| 2 | `crc32_data` | `0x40000800` |

## How It Works

- **UARTWishboneBridge** (`litex.soc.cores.uart`) instantiates an RS232 PHY and translates serial commands from `litex_server` into Wishbone bus transactions.
- **CRC32Peripheral** wraps `hdl/crc.vhdl` via a Migen `Instance` (black-box). On each host write, the lower 8 bits of the written value are passed to the VHDL entity, and the combinatorial output becomes the new accumulator value. The accumulator is initialised to `0xFFFFFFFF` on system reset.
- **Read path**: The host reads the bit-inverted accumulator (`~out_buf`), which is the standard CRC32 final-XOR step. At power-on (no bytes written), this reads as `0x00000000`.
- The **CSR decoder** inside `SoCMini` maps the peripheral's CSR register to `0x40000800` using `csr_address_width=14` and `csr_paging=0x400`.

## Running Tests

```bash
python testBenchCrc32Peripheral.py
```

The testbench uses a pure-Migen CRC32 step (bit-for-bit mirror of `hdl/crc.vhdl`) because Icarus Verilog cannot simulate VHDL black-boxes. All other peripheral logic is identical to the synthesis design.

The simulation verifies:

- **Test 1**: Checksum at power-on (no writes) equals `0x00000000`
- **Test 2**: Single byte `0x31` produces the correct CRC32
- **Test 3**: Accumulation continues correctly after further bytes
- **Test 4**: System reset clears the accumulator back to initial state
- **Test 5**: Byte-by-byte accumulation of `0xDEADBEEF` matches `tbLib/crcLib.py` at every step
- **Test 6**: Upper bits `[31:8]` in a write are ignored — `0xDEADBE31` is treated as `0x31`

A `test_crc32_peripheral.vcd` waveform file is generated for inspection in GTKWave.
